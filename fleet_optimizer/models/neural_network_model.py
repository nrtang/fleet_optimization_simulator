"""
Neural Network Model for Fleet Optimization

This model uses supervised learning to learn from expert demonstrations.
It predicts optimal actions for each vehicle based on extracted features.
"""

import torch
import torch.nn as nn
import numpy as np
from typing import List, Dict, Optional
from .base_model import BaseOptimizationModel
from ..utils.feature_extraction import StateFeatureExtractor


class FleetPolicyNetwork(nn.Module):
    """
    Neural network that predicts vehicle actions.

    Architecture:
    - Input: State features (26) + Vehicle features (7) = 33 features
    - Hidden layers: 128 -> 64 -> 32
    - Output: Action logits (4 actions) + Value estimate
    """

    def __init__(self, state_dim: int = 26, vehicle_dim: int = 7, hidden_dim: int = 128):
        super().__init__()
        input_dim = state_dim + vehicle_dim

        self.shared_layers = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_dim, 64),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(64, 32),
            nn.ReLU()
        )

        # Action head (4 actions: IDLE, PICKUP, CHARGING, REPOSITION)
        self.action_head = nn.Linear(32, 4)

        # Request selection head (which request to pick up)
        self.request_head = nn.Sequential(
            nn.Linear(32, 16),
            nn.ReLU(),
            nn.Linear(16, 1)
        )

        # Depot selection head (which depot to go to)
        self.depot_head = nn.Sequential(
            nn.Linear(32, 16),
            nn.ReLU(),
            nn.Linear(16, 1)
        )

        # Value head (for training with advantage estimates)
        self.value_head = nn.Linear(32, 1)

    def forward(self, x):
        """
        Forward pass through the network.

        Args:
            x: Tensor of shape (batch_size, input_dim)

        Returns:
            action_logits: Tensor of shape (batch_size, 4)
            value: Tensor of shape (batch_size, 1)
        """
        shared = self.shared_layers(x)
        action_logits = self.action_head(shared)
        value = self.value_head(shared)
        return action_logits, value

    def predict_request_score(self, x):
        """Score for request selection."""
        shared = self.shared_layers(x)
        return self.request_head(shared)

    def predict_depot_score(self, x):
        """Score for depot selection."""
        shared = self.shared_layers(x)
        return self.depot_head(shared)


class NeuralNetworkModel(BaseOptimizationModel):
    """
    Neural Network-based optimization model.

    Uses supervised learning to learn from expert demonstrations.
    Can be trained on data generated by greedy or other models.
    """

    # Action indices
    ACTION_IDLE = 0
    ACTION_PICKUP = 1
    ACTION_CHARGING = 2
    ACTION_REPOSITION = 3

    def __init__(self, config: dict = None):
        super().__init__(config)
        self.feature_extractor = StateFeatureExtractor()

        # Model parameters
        self.model_path = config.get('model_path', 'trained_models/neural_network_model.pt')
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.low_battery_threshold = config.get('low_battery_threshold', 0.25)
        self.max_pickup_distance_km = config.get('max_pickup_distance_km', 15.0)
        self.temperature = config.get('temperature', 1.0)  # For softmax sampling

        # Initialize network
        self.network = FleetPolicyNetwork()
        self.network.to(self.device)

        # Load trained weights if available
        try:
            checkpoint = torch.load(self.model_path, map_location=self.device)
            if isinstance(checkpoint, dict) and 'model_state_dict' in checkpoint:
                self.network.load_state_dict(checkpoint['model_state_dict'])
                print(f"Loaded trained model from {self.model_path}")
            else:
                self.network.load_state_dict(checkpoint)
                print(f"Loaded trained model weights from {self.model_path}")
        except FileNotFoundError:
            print(f"Warning: No trained model found at {self.model_path}")
            print("Using randomly initialized weights. Train the model first for better performance.")
        except Exception as e:
            print(f"Warning: Error loading model: {e}")
            print("Using randomly initialized weights.")

        self.network.eval()

    def _extract_vehicle_features(self, vehicle, state: dict) -> np.ndarray:
        """
        Extract features for a specific vehicle.

        Returns 7-dimensional feature vector:
        - battery_level
        - is_available (0/1)
        - is_charging (0/1)
        - distance_to_nearest_depot (normalized)
        - distance_to_nearest_request (normalized)
        - current_lat (normalized)
        - current_lon (normalized)
        """
        features = np.zeros(7, dtype=np.float32)

        features[0] = vehicle.battery_level
        features[1] = 1.0 if vehicle.available else 0.0
        features[2] = 1.0 if vehicle.is_charging else 0.0

        # Distance to nearest depot
        min_depot_dist = float('inf')
        depots = state['depots']
        distance_func = state['distance_func']

        for depot in depots.values():
            dist = distance_func(
                vehicle.current_lat, vehicle.current_lon,
                depot.latitude, depot.longitude
            )
            min_depot_dist = min(min_depot_dist, dist)

        features[3] = min(min_depot_dist / 50.0, 1.0)  # Normalize to [0, 1]

        # Distance to nearest request
        min_request_dist = float('inf')
        requests = state['active_requests']

        if requests:
            for request in requests.values():
                dist = distance_func(
                    vehicle.current_lat, vehicle.current_lon,
                    request.pickup_lat, request.pickup_lon
                )
                min_request_dist = min(min_request_dist, dist)
            features[4] = min(min_request_dist / 50.0, 1.0)
        else:
            features[4] = 1.0

        # Normalized position
        features[5] = (vehicle.current_lat - 37.0) / 1.0  # Rough normalization for SF
        features[6] = (vehicle.current_lon + 122.0) / 1.0

        return features

    def make_decisions(self, state: dict) -> List[dict]:
        """
        Make decisions for all available vehicles using the neural network.

        Args:
            state: Current simulation state

        Returns:
            List of decision dictionaries
        """
        decisions = []
        fleet = state['fleet']

        # Extract global state features once
        state_features = self.feature_extractor.extract_state_features(state)
        state_tensor = torch.FloatTensor(state_features).to(self.device)

        for vehicle in fleet.vehicles.values():
            if not vehicle.available:
                continue

            # Extract vehicle-specific features
            vehicle_features = self._extract_vehicle_features(vehicle, state)
            vehicle_tensor = torch.FloatTensor(vehicle_features).to(self.device)

            # Combine state and vehicle features
            combined_features = torch.cat([state_tensor, vehicle_tensor]).unsqueeze(0)

            # Get action predictions
            with torch.no_grad():
                action_logits, value = self.network(combined_features)
                action_probs = torch.softmax(action_logits / self.temperature, dim=-1)

            # Select action (greedy selection, can also use sampling)
            action_idx = torch.argmax(action_probs, dim=-1).item()

            # Convert action index to decision
            decision = self._action_to_decision(
                vehicle, action_idx, state,
                combined_features, action_probs
            )

            if decision:
                decisions.append(decision)

        return decisions

    def _action_to_decision(
        self,
        vehicle,
        action_idx: int,
        state: dict,
        features: torch.Tensor,
        action_probs: torch.Tensor
    ) -> Optional[dict]:
        """
        Convert neural network action to simulator decision.

        Args:
            vehicle: Vehicle object
            action_idx: Predicted action index
            state: Current state
            features: Combined state+vehicle features
            action_probs: Action probabilities

        Returns:
            Decision dictionary or None
        """
        # Safety check: always charge if battery is critically low
        if vehicle.battery_level < self.low_battery_threshold:
            return self._select_charging_depot(vehicle, state)

        if action_idx == self.ACTION_IDLE:
            return {
                'vehicle_id': vehicle.vehicle_id,
                'action': 'IDLE'
            }

        elif action_idx == self.ACTION_PICKUP:
            return self._select_pickup_request(vehicle, state, features)

        elif action_idx == self.ACTION_CHARGING:
            return self._select_charging_depot(vehicle, state)

        elif action_idx == self.ACTION_REPOSITION:
            return self._select_reposition_location(vehicle, state)

        return None

    def _select_pickup_request(
        self,
        vehicle,
        state: dict,
        features: torch.Tensor
    ) -> Optional[dict]:
        """Select best request to pick up using neural network scoring."""
        requests = state['active_requests']
        distance_func = state['distance_func']

        if not requests:
            return {'vehicle_id': vehicle.vehicle_id, 'action': 'IDLE'}

        # Score each request
        best_request = None
        best_score = float('-inf')

        for request in requests.values():
            # Calculate distance
            dist = distance_func(
                vehicle.current_lat, vehicle.current_lon,
                request.pickup_lat, request.pickup_lon
            )

            # Skip if too far
            if dist > self.max_pickup_distance_km:
                continue

            # Simple heuristic scoring (can be replaced with neural network)
            wait_time = state['current_time'] - request.request_time
            score = -dist - wait_time * 0.1

            if score > best_score:
                best_score = score
                best_request = request

        if best_request:
            return {
                'vehicle_id': vehicle.vehicle_id,
                'action': 'PICKUP_PASSENGER',
                'request_id': best_request.request_id
            }

        return {'vehicle_id': vehicle.vehicle_id, 'action': 'IDLE'}

    def _select_charging_depot(self, vehicle, state: dict) -> dict:
        """Select nearest available charging depot."""
        depots = state['depots']
        distance_func = state['distance_func']

        best_depot = None
        min_distance = float('inf')

        for depot in depots.values():
            if depot.has_available_chargers():
                dist = distance_func(
                    vehicle.current_lat, vehicle.current_lon,
                    depot.latitude, depot.longitude
                )
                if dist < min_distance:
                    min_distance = dist
                    best_depot = depot

        if best_depot:
            return {
                'vehicle_id': vehicle.vehicle_id,
                'action': 'CHARGING',
                'depot_id': best_depot.depot_id
            }

        return {'vehicle_id': vehicle.vehicle_id, 'action': 'IDLE'}

    def _select_reposition_location(self, vehicle, state: dict) -> dict:
        """
        Select reposition location based on demand prediction.
        Currently uses simple heuristic (move towards requests).
        Can be enhanced with demand prediction network.
        """
        requests = state['active_requests']

        if not requests:
            return {'vehicle_id': vehicle.vehicle_id, 'action': 'IDLE'}

        # Calculate center of mass of pending requests
        avg_lat = np.mean([r.pickup_lat for r in requests.values()])
        avg_lon = np.mean([r.pickup_lon for r in requests.values()])

        return {
            'vehicle_id': vehicle.vehicle_id,
            'action': 'REPOSITION',
            'target_lat': avg_lat,
            'target_lon': avg_lon
        }
